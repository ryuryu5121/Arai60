# step1
考えたこと
- 前回の問題との相違点
  - 問題的からサイクルが発生しているNodeを返すことが求められていると考えた
  - 前回の問題では、進む速さが異なるNodeを２つ用意し、Nodeが追いつくかその前にNoneを返すかで判定を行った
  - 今回の場合、その方法用いると追いついた際のNodeを返すことになり、求められている解と異なる
  - よって、set()を利用したコードを使用することにした。これにより、保存していたNodeに再度出現したNodeを含まれるかどうかで判定を行うことができる

# step2
- 前回の問題を参考に、set()を使う解法とfast・slowの２パターンも取り組んだ
- set()を使う方法が思いつくかどうかが試されているというコメントを拝見したため、この考え方を忘れないようにしたい
- 判定する際にis , is not を使うことで可読性を上げる意識
- while文の可読性（長い処理をあえてメソッド化 or breakで外に出す）